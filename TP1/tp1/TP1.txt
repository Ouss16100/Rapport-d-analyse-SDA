1) Définition pour la fonction potentielle dans le cas ou α >= 1 : 

Φi = 2 × nomi - taillei


2) Le cout amorti de l'opération Inserer-Table en fonction de α 

cout amorti = cout reél + Φap - Φav

cas1: pas d'extension  (tailleap = tailleav), (nomap = nomav+1)

cout amorti = cout reél +(α × nomap - tailleap) - (α × nomav - tailleav) 
            = 1 +  α × nomap - tailleap - α × nomav + tailleav
            = 1 + α(nomap - nomav)
            = 1 + α
cas2: extension (tailleap = α × tailleav), (nomap = nomav+1), (tailleav)

cout amorti = cout reél + (α × nomap - tailleap) - (α × nomav - tailleav)
            = nomap + α × nomap - tailleap - α × nomav + tailleav
            = nomav + 1 +  α × (nomav + 1) - α × tailleav - α × nomav + tailleav
            = nomav +1 + α - α × tailleav + tailleav
             

3.a)
-Lors de l'exécution des programmes, le morceau du code qui semble prendre le plus de temps a s'exécuter est le sauvegarde des données de l'expérience.
-La complexité des ces fonctions est 
-Parce que les operation sur le disque dur prennent plus de temps

3.b)
-Le cout amorti augemnte lorsque de l'allocation de mémoire, parce que le cout amorti est en relation avec la taille du tableau et augemnte lorsque l'augmentation de la taille du tableau ( c'est bien remarquable en java)

3.c)
-On remarque que lorsque l'allocation de mémoire le nombre de copies effectuées augmente, c'est du au fait que le tableau sera plein on doit proceder a une extention du tableau, on alloue la mémoire pour le nouveau tableau et on doit recopier toute les valeurs qui ils était dans l'ancien tableau dans le nouveau.
-La difference avec le temps réel mesuré l'allocation de la mémoire et le nombre de copies effectués ce passe au méme moment.

3.d)
- Le cout amortie change d'une expérience a une autre ainsi que le total coast (le temps prix par l'opération), average coast(qui change avec le changement du total coast), la variance, et la standard deviation.
- Ce qui ne change pas c'est le nombre de copies, le moment de l'allocation de mémoire.

3.e)
- On distingue deux deux types de langages : les lagages interprétés et les langages compilés, le C et le C++ sont plus rapide parce que ce sont des langages interprétés qui sont d'abord compilé pars un logiciel qu'on appelle compilateur et c'est le systéme d'exploitation qui va utiliser le code binaire( resultat de la compilation) et les données d'entrée pour calculer les données de sortie. Contrairement au PYTHON et JAVA qui sont des langage interprétés ce qui veut dire qu'un interpréteur va utiliser le code source et les données d'entrée pour calculer les données de sortie.

3.f)
- L'espace mémoire inutilisé est le méme dans le C, JAVA ET C++, Il ne descend pas jusqu'au zero c'est du a la condition d'extention du tableau dans la fonction do_we_need_to_enlarge_capacity() qui est si trois quart de la table est plein renvoie true donc on procede a l'extension du tableau.
- Donc l'espace mémoire inutilisé au moment de la reallocation de mémoire est de (1/4)ancien_table+ancien_table = (5/4)ancien_table.
- Le scénario dans lequel cela pourrait poser probléme c'est dans le cas ou insére un élément au tableau on fait la reallocation et on aura plus d'insértion donc la mémoire initulisé sera grande, on a aussi le probléme qu'on utilise jamais la totalité de la mémoire donc on aura toujours de l'espace mémoire inutilisé. 

4) Dans l'image 4.png, on a gauche le resultat aprés modification de la fonction do_we_need_to_enlarge_capacity, a droite l'ancien resultat.
- On remarque que lorsque la modification de la fonction do_we_need_to_enlarge_capacity pour ne déclencher que lorsque le tableau est plein on va econmiser de l'espace mémoire, qui veux dire que l'espace mémoire inutilisé diminue parraport a la premiére experience.
- L'utilisation de precque toute la mémoire alloue est aussi remarquable.
- On a aussi plus d'operation de reallocation de mémoire qu'avant.

5)
- Premiérement la reallocation de mémoire depend aussi de la variation du facteur multiplicatif α, on augmentant ce dernier on fait moin de reallocation (ce qui est logique) et on a le contraire aussi, ce que veux dire quand on diminue ce facteur multiplicatif on fait moin de reallocation.
- L'espace mémoire inutilisé diminue aussi lorsqu'on diminue ce facteur multiplicatif l'espace mémoire inutilisé diminue mais le cout on temps augmente, le contraire est vrais aussi qui veux dire que lorsqu'on augmente le facteur multiplicatif, l'espace mémoire inutilisé augmente et le cout on temps diminue.
- le cout en temps et le cout en espace sont on corrélation inverse.

6) Lorsqu'on varie la capacité n vers une capacité n+sqrt(n) on remarque que l'espace mémoire lorsque de la reallocation mémoire, l'espace mémoire alloue s'utilise moin rapidement que lorsuq'on a une capacité n.








































